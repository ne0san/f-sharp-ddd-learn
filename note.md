# 概要
「関数型ドメインモデリング」の学習内容をアウトプットするスクラップ
https://amzn.asia/d/i3VaTIU


# Todo: 書籍のコードrepoを探す

https://github.com/swlaschin/DomainModelingMadeFunctional

# 前提条件
私の学習前は以下の状態である
- F#は軽く触ったことがある程度
- ドメイン駆動設計は名前とざっくりした概要を知っている程度
- 設計に関する体系的学習はしたことがない
- 実務において詳細設計以下のフェーズは多く担当

# 本スクラップの書き方
内容を適当に要約して書いている
理解が足りていない部分は「?」をつけたりする

# 第1章 ドメイン駆動設計の紹介

## DDDとは
ソフトウェア開発を入出力(要件→成果物)で例えると
「ゴミが入るとゴミが出てくる」。
コミュニケーションとドメイン知識に焦点を当てた設計により、
ゴミが入る部分を最小限にする。

1章では以下を説明
- DDDの原則
- ドメインにどう適用できるか

ただしすべての開発に適しているわけではない。

## 1-1 モデルを共有することの重要性

実際にリリースされるのは開発者の理解
→ドメインエキスパートのものではない

仕様書や要件定義書で問題のすべてを把握しようとすると、
開発者(解決手段を作る者)とドメインエキスパート(問題を理解している者)の間の距離が空く

### ドメインエキスパートとは
問題を最も理解している人


## ドメイン駆動設計の目標

以下がすべて同じモデルを共有すること
- ドメインエキスパート
- 開発チーム
- ステークホルダ
- ソースコード
これにより翻訳の必要性がなくなる

### 共有モデルを作るガイドライン
- データ構造ではなくビジネスイベントやワークフローに着目
- ドメインをより小さなサブドメインに分割
- 各サブドメインのモデルを解決空間に作成する
- PJ関係者全員共有で、コードのあらゆる場所で使用される共通言語を開発

## 1-2 ビジネスイベントによるドメインの理解
典型的なビジネスプロセスはデータ変換の連続

### 「ドメインイベント」とは
モデル化したいビジネスプロセスの出発点
何らかの作業を開始するきっかけとなる外部からのトリガーのようなもの?

過去形で書く。きっかけのイベント自体は不変の事実

### イベントストーミングによるドメインの探索

ドメイン内のイベントを発見する方法のうちDDDのアプローチに特に適しているもの
ビジネスイベントとそれに関連するワークフローを発見する

#### やり方
ドメインの様々な部分を理解している人(質問がある人、答えられる人)を招集、ファシリテータつきのワークショップを開催

1. ビジネスイベントを付箋に書き出し壁に貼る
2. 他の人がその出来事をきっかけとしたビジネスワークフローをまとめたメモを貼る
3. メモを時系列に整理
4. 参加者全員、知っていることは壁に貼り、知らないことは質問

### ドメインを探索：受注システム

どこからでもいいのでビジネスイベントを壁に貼り出す。
作業のきっかけをビジネスイベントとする。

#### ビジネスの共通モデル

参加者全員でビジネスに対する共通認識をもつ
チーム間の対立構造を無くす

#### 全チームの把握

各チーム間における相互関係の抜け漏れを防ぐ
自チームのイベントにのみ着目すると他チーム部分の抜けが気づけるような感じ

#### 要件抜け漏れなど発見

抜けてるイベントとかに気づける
明確な答えが無い場合は議論のきっかけにする。

#### チーム間連携

あるチームのアウトプットが別のチームのインプットかもしれない
その依存関係そのものを明らかにする


#### レポーティング
過去に起こったことを理解する。
読み取られるだけのモデルがあるはず

### イベントを端まで広げる
イベントの連鎖をシステム境界まで広げる
これにより不足要件を見つけられる

必ずしもすべてシステム化する必要はない。ビジネスプロセスへの理解を優先

### コマンドの文書化

コマンド成功
↓
ワークフロー開始
↓
対応するドメインイベント作成

この方法でビジネスプロセスをモデル化する。

プロセスを入力と出力を持つパイプラインとする考えは関数型とマッチする。
関数型はある値を渡したら出力となる値が返却される

#### コマンドとは
ドメインイベントを引き起こそうとした依頼のことをDDDではコマンドと表現
常に現在形

「A社に発注する」
このコマンドに対するドメインイベントは
「発注された」

※イベント→コマンドの流れがわかってないので次はそこから

## 1-3 ドメインをサブドメインに分割

受注をより小さなサブドメインに分割する例
- 受注
- 発送
- 請求

### ドメインとは
首尾一貫した知識領域

プログラマはある意味ドメインエキスパート
「Webプログラミング」は「プログラミング一般」のサブドメインといえる
さらに特定言語や分野などもドメインの一種といえる

ドメイン同士をベン図にすると領域に重複部分がある

受注を分割したサブドメインでも同様のことがいえる。

## 1-4 境界付けられたコンテキストを利用した解決手段の作成

重複部分があるドメインを設計プロセスで境界付ける

問題空間
→ドメイン

をモデル化

解決空間
→境界付けられたコンテキスト

### 境界付けられたコンテキストとは
いわゆるサブシステムのようなもの
境界を意識づけるためにこのように呼ばれる

 解決手段における専門的知識を表す

 問題空間のドメインが解決空間のコンテキストと常に1:1とは限らない
 複数のドメインを解決するサブシステムがあるかもしれない

 ### コンテキストを正しく区別する
 ### コンテキストマップ作成
 コンテキストを定義した後は設計の詳細に巻き込まれないようにIFを定義
 これをコンテキストマップという
 ### 最も重要なコンテキストに焦点を当てる

 ドメイン同士の重要度は異なる
 ビジネス上の優位性があるものなど(企業の強みとか)
 コアではないドメインは支援ドメインという
 企業固有でないものは汎用ドメインという

 優先順位をつけて並列実装するべきではない

 ## 1-5 ユビキタス言語の創造
 ドメインエキスパートとコードが同じモデルを使う必要がある
 「注文」に対応して「Order」が必要
 ドメインエキスパートの中に含まれていないもの(「OrderHelper」等)は設計に含めない

 ### ユビキタス言語
 チーム全員が共有する概念と語彙のセット

 PJ内あらゆる場所で使われるべき
 もちろんコード上でも

 この言語構築はチーム全員で協力して行う
 さらにこれは随時更新されることが前提

# 第2章 ドメインの理解

特定のワークフローについての掘り下げのステップ

- トリガーになるもの
- 必要なデータ
- 関連付けが要る境界付けられたコンテキストは他にあるか

ドメインエキスパートについて注意深くヒアリングする必要がある

## 2-1ドメインエキスパートへのインタビュー

コマンド/イベントごと
一つのワークフローに焦点を当てた短いインタビューを何度も行う

最初はWFのi/oにのみ焦点を当てる

先入観を持たずにどのようなニーズがあるかを聞き取る

### 非機能要件の理解

WFの文脈や規模についても聞いてみる

### 残りのWFの理解
I/Oを整理

WFのアウトプットはWFが生成するイベント

また、そのWFでどのような副作用が起こるかも整理する

## DB設計について
DBは一旦おいておいて設計するのがいい
ユーザはデータ永続化方法については考えていないしユビキタス言語にも含まれていない

ドメインそのもののモデル化に集中する

これを永続化非依存という

## クラス駆動について
クラス設計したとき、実在しない基底クラスを作ってしまうことがある。
当然これはドメインエキスパートには理解できない代物

## ドメインの文書化

要件をどうやって記録すべきか

WFとデータ構造を文書化

これをドメインエキスパートに見せて一緒に作業できるレベルで簡単に構造化

コードについても同様にできるかは後に

## WFを深堀
i/oが分かったところで受注のWFを具体的に理解

- クライアントの利益として何が優先事項になるか把握
- 実はコンテキスト外のサードパーティのサービスを使用していた
- 「場合による」が出てきたら複雑になる

## 複雑さをドメインモデルで表現

深堀して得た情報をテキストベースで表現

### 制約条件の表現

### ライフサイクルを表現
データモデルとして、検証済みのものとそうでないものを別定義するなど、

未検証の注文には未検証の住所があり、
検証済みの注文には検証済みの住所があるなど

### WFステップを具体化

WFをより小さなステップに細分化

サブステップごとに入出力と依存関係を定義
どんな入力が来て、どんな出力がされうるか
例
入力：未検証の注文
出力：検証済みの注文or検証エラー
依存関係：外部サービス

# 三章 関数型アーキテクチャ

ドメインの理解を関数型プログラミングの原則に基づいたアーキテクチャに落とし込む

システムへの理解は引き続き行う
モデルを同実装するかを大まかなアイデアを持っておく

ソフトウェアアーキテクチャ自身もドメインなので、ユビキタス言語で

## 「C4」アプローチ
- 「システムコンテキスト」 -> システム全体を表す最上位の概念　複数のコンテナから成る
- 「コンテナ」-> デプロイ可能な単位 多数のコンポーネントから成る
- 「コンポーネント」コード構造で主要な構成要素 多数のクラスから成る
- 「クラス」(関数型では「モジュール」)低レベルメソッドや関数の集合
各概念間の境界を定義し、変更コストを最小限に抑える

## 自律的ソフトウェアコンポーネントとしての境界付けられたコンテキスト

コンテキストは自律的サブシステムで、明確に定義された境界を持つ

これでも選択肢多数
- 単一モノリシックなデプロイ
- 境界付けられたコンテキスト単位でのデプロイ -> サービス指向アーキ
- ワークフローを独立してデプロイ可能なコンテナ単位にする -> マイクロサービス
ただしこの時点では特定のアプローチにとらわれなくていい
コンテキストが独立・自律的である限り

ドメインの理解が深まるにつれて協会は変化する

最初はモノリスにして、必要に応じて疎結合コンテナにリファクタするなど

## 境界付けられたコンテキストのコミュニケーション

イベントを発行することでコンテキスト同士のコミュニケーションを行う

真に自律的コンポーネントにするには疎結合にする

具体的なメカニズムはアーキテクチャによる

## コンテキスト間のデータ転送

### DTO
イベントは下流コンポーネントが処理するためのデータをすべて含む
データが大きすぎる場合は共有ストレージの位置を示すなど
コンテキスト間のデータ転送に使うデータオブジェトのことを言う。

境界付けられたコンテキスト内で定義されたオブジェクト(ドメインオブジェクト)とは異なる

### 信頼の境界線と検証

コンテキストの外側にあるものは信頼されておらず無効の可能性がある

#### ゲート
ワークフローの最初と最後に追加
ドメインと外の仲介

入力ゲートは入力値が制約を満たすか常に確認

出力ゲートはコンテキストの外にプライベートな情報が漏れないようにする

## コンテキスト間の契約

### 共有カーネル関係
共通のドメイン設計を持つ

DTO定義を変更するときは他のコンテキストの所有者と協議する

### 顧客/供給者
下流が上流に提供してほしい契約を定義

### 順応者

下流は上流のコンテキストが提供する契約を受け入れる

### 腐敗防止層
外部システムとの連携時にIFがまったく一致しない場合、コンテキスト内で変換する必要がある
↓
外部適応しようとして内部ドメインモデルが「腐敗」

コンテキスト間疎結合の追加レベルとして置くもの


## コンテキストでのワークフロー

コンテキスト内ではドメインイベントの使用を避ける
隠れた依存関係が発生するため

## コンテキスト内のコード構造

レイヤー化アプローチではコードを各層に分ける
この時ワークフローの動作を変更するとすべてのレイヤーに手を入れる必要がある

### オニオンアーキテクチャ

ドメインコードを中心に置き、各レイヤーが内部のレイヤーにのみ依存する構造

ヘキサゴナルアーキテクチャやクリーンアーキテクチャなど類似したアプローチがある。
依存が内側に向くようにするためにDIまたはそれに類する機能を使う

### IOを端に追いやる

副作用をWFの開始時と終了時にする
WF内部ではDBにアクセスできない

# 4章 型の理解

人間にしか理解できない方をいかにコードに落とし込むか

## 関数の理解

### 型シグネチャ
`int -> int`
intを入れたらintが返却されることを示す

```fsharp
let add1 x = x + 1 // int -> int
let add x y = x + y // int -> int -> int
```
F#はほとんどの場合コンパイラが型推論する

### ジェネリック型

f#では `'a`のようにシングルクォートがついたものはジェネリック型

## 型と関数
### 型とは
関数の入手出力として使用可能な値の集合に与えられた名前

### 値
入出力に使えるもの
不変なので変数ではない

### オブジェクト
データ構造と動作を含めたもの

## 型の合成
```fsharp
// レコード型
// フィールド3つが含まれる
// AND型
type Cube = {
    Depth: int
    Height: int
    Width: int
}

// 判別共用体
// DepthかHeightかWidthでタグ付けされたintがある
// OR型
type Figure =
    | Depth of int
    | Height of int
    | Width of int
```

### 単純型

判別共用体(選択型)で一つしかない型を定義することがドメインモデリングではよくある
```fsharp
type Length =
    | Length of int
```
ラッパーを簡単に作れるので

### 代数的型システム

すべての複合型がより小さな型をANDかORで合成してできているもの

## F#の型を使う
```fsharp
// レコードを作成
let cube = {Depth= 5; Height= 2; Width=5}

// パターンマッチでレコードをバラす
let {Depth=depth; Height=height; Width=width} = cube

printfn "%d, %d, %d" depth height width
```

```fsharp
// 選択型のケースラベルのいずれかをコンストラクタ関数として使用する
let fd = Depth 4
let fh = Height 34
let fw = Width -489

// パターンマッチで選択型をバラす
let printFigureValue v =
    match v with
    | Depth d ->
        printfn "depth %d" d
    | Height h ->
        printfn "height %d" h
    | Width w ->
        printfn "width %d" w

printFigureValue fd
printFigureValue fh
printFigureValue fw
```


## 型の合成によるドメインモデル構築

型の定義をしたのち、これら型に関する関数を作成(メソッドではない)

## 省略可能な値、エラー、コレクションのモデリング

### 任意の値
Option型を使う

### エラー
Result型を使う

### 値が存在しないこと
unitを使う(関数型では関数は何かしらの値を返却しなければならないのでvoidはない)
型シグネチャでunitがあるということは副作用があることを強く示す

### コレクション
いくつかある
- list
- array
- ResizeArray
- seq
- set
- map
ドメインモデリングでは常にlistをした方が良い

## ファイルやプロジェクトでの型の整理
ドメイン型を一つにまとめる
依存する関数はそのファイルのうしろにまとめる

# 5章 型によるドメインモデリング

共有されたドメインモデルがコードにも反映されていなければならない

これができていればドメインモデルをコードに翻訳する必要が無い

理想的には他の非開発者がコードレビューや設計確認できるのが望ましい

この強力な型システムで設計と実装がずれない

## 単純な値

ドメインエキスパートはintやstringではなく、OrderId等のドメインの概念で型を考える

おなじintであらわされるものでも互換性があるわけではないことを明確にする

単純型を作る
```fs
type CustomerId = CustomerId of int
//   ^型名         ^ケースラベル
let customerId = CustomerId 42
```
単純型ではケースラベルと型名を同一にする
ケース名がコンストラクタになるから

同じintでも別の単純型にすることで混同しないようになる
分解するにはケースラベルでパターンマッチ
```fs
let (CustomerId innerValue) = customerId
printfn "%d" innerValue
```


関数定義で直接分解することはある
```fs
let processCustomerId (CustomerId innerValue) = 
    printfn "%d" innerValue
```

### 単純型のパフォーマンス問題を回避


単純型を使用することは
メモリ使用率と効率性の犠牲がある

改善例
- 単純型ではなく型エイリアスを使う -> 型の安全性は下がる
```fs
type UnitQuantity = int
```
- 参照型ではなく値型(構造体)を使う
```fs
[<Struct>]
type UnitQuantity = UnitQuantity of int
```
- コレクション全体を一つの型とする
```fs
type UnitQyantities = UnitQyantities of int[]
```

## 複雑なデータ

Orderが下記のようになっている場合
```
data Order = 
    CustomerInfo
    AND ShippingAddress
    AND BillingAddress
    AND list of IrderLines
    AND AmountToBill
```
↓
```fs
type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill : AmountToBill
}
```
この時、複雑な型で使用される型の実態が不明

ドメインエキスパートに協力してもらうことで実現した方が良い
ShippingAddressとBillingAddressを別物として扱う場合は論理的に分離するなど

### 未知の型のモデリング

モデリングしたい型の明確な型が不明な場合がある

未定義の型を表現したい場合、例外型のexnをUndefinedとエイリアスする

```fs
type Undefined = exn

type CustomerInfo = Undefined
type ShippingAddress = Undefined
type BillingAddress = Undefined
type OrderLines = Undefined
type AmountToBill = Undefined

type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill : AmountToBill
}
```

### 選択型によるモデリング

```
data ProductCode = 
    WidgetCode
    OR GizmoCode
```

```fs
type ProductCode = 
    | WidgetCode of WidgetCode
    | GizmoCode of GizmoCode
```

ここまでで名詞をモデリングできる

## ワークフローのモデリング

動詞をモデリングする

```fs
type ValidateOrder = UnvalidatedOrder -> ValidatedOrder
```

### 複雑な入出力

#### 出力

AとBの両方を出力する場合、そのようにするレコード型を作成

```fs
type out = {
    A : A
    B : B
}
```
どちらかを出力する場合は、選択型にする

```fs
type out =
    | A of A
    | B of B
```

#### 入力

入力に選択肢がある場合、選択型にする

すべて必須であるとき、複数のアプローチになる


- 別のパラメータとする
```fs
// Bが入力ではなく依存関係である場合はこのアプローチ
// DIと同等の機能を使える
type WorkFlow = A -> B -> Out
```
- 入力用のレコード型
```fs
// AとBそれぞれの入力が常に必要である場合
// タプルでもできるが、名前付きの型の方が良い
type Input = {
    A : A
    B : B
}
type WorkFlow = Input -> Out
```

### 関数のシグネチャでエフェクトを文書化

#### エフェクトとは

関数が主な入出力以外に行うことを説明する時に使う言葉

例えば、検証する関数で検証失敗が発生する場合はResult型
非同期処理をする場合Async型を返却するなど

```fs
type ValidateOrder =
    UnvalidatedOrder -> Async<Result<ValidatedOrder, ValiudatioinError list>>
```
さらに型エイリアスで見た目を整える
```fs
type ValidationResponse<'a> = Async<Result<'a, ValiudatioinError list>>
type ValidateOrder = UnvalidatedOrder -> ValidationResponse<ValidatedOrder>
```

## アイデンティティの考察

永続的なIDを持つかどうかでデータ型を分類

### エンティティ
永続的なアイデンティティを持つオブジェクト

### 値オブジェクト
永続的なアイデンティティを持たないオブジェクト

例
WidgetCodeのインスタンスが"W123"同士である場合、等価とみなす

```fs
type WidgetCode = WidgetCode of string
let widgetCode1 = WidgetCode "W123"
let widgetCode2 = WidgetCode "W123"
printfn "%b" (widgetCode1 = widgetCode2) // true
```

単純型でなくとも当てはまる
```fs
[<Struct>]
type FirstName = FirstName of string
[<Struct>]
type LastName = LastName of string
[<Struct>]
type PersonalName = {
    FirstName : FirstName
    LastName : LastName
}
let name1 = {
    FirstName = FirstName "test";
    LastName = LastName "test2"
}
let name2 = {
    FirstName = FirstName "test";
    LastName = LastName "test2"
}
printfn "%b" (name1 = name2) // true
```

### 値オブジェクトの透過性の実装

F#はデフォルトでフィールドベースの透過性を実装してくれる。しゅごい！

選択型なら同じケースで内容が同じ値であるときに等しくなる

## アイデンティティ

### エンティティとは

構成要素が変わっても固有のアイデンティティを持つものであることをモデル化することがよくある
このようなもの

ビジネス上では多くの場合、何らかの文書

ライフサイクルがあり、ビジネスプロセスである状態から別の状態に変換される

#### 何をエンティティとするか
文脈次第

端末製造過程で固有のシリアルが与えられる場合、
その端末はエンティティである

販売時はシリアルは関係ない
この場合は値オブジェクト

### エンティティの識別子

他の値がどんな変更があっても安定している必要がある
IDのような一意のキーを与える必要がある

このキーは実際のドメイン自体によって提供される場合がある
無ければUUIDなど自前で作る必要がある
```fs
type UserId = UserId of string

type User = {
    UserId: UserId
    // あとは省略
}
// 他のパラメータが変わってもUserIdが不変
```

### データ定義への識別子の追加

モデルの内側に識別子を追加するのが一般的

外側にすると型が複数に分散する


```fs
type UnpaidInvoice = {
    InvoiceId : InvoiceId //内側にあるID
    // その他各パラメータ
}

type PaidInvoice = {
    InvoiceId : InvoiceId
    // その他各パラメータ
}

type Invoice = 
    | Unpaid of UnpaidInvoice
    | Paid of PaidInvoice
```

この時、パターンマッチでIDも含めてすべてのデータを一度で見れる

### エンティティに対する等価性の実装

同一のエンティティであるか確認するために
識別子だけ比較したい

以下を行う

1. Equalsをオーバーライド
2. GetHashCodeをオーバーライド
3. CustomEqualityとNoComparison属性を追加して、デフォルトの動作を変えたことをコンパイラに伝える